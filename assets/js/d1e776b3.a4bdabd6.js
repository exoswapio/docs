"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[337],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),s=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=s(n),m=a,k=d["".concat(u,".").concat(m)]||d[m]||p[m]||o;return n?r.createElement(k,l(l({ref:t},c),{},{components:n})):r.createElement(k,l({ref:t},c))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=m;var i={};for(var u in t)hasOwnProperty.call(t,u)&&(i[u]=t[u]);i.originalType=e,i[d]="string"==typeof e?e:a,l[1]=i;for(var s=2;s<o;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1632:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var r=n(7462),a=(n(7294),n(3905));const o={id:"bridge-router",title:"Bridge Router",description:"Build your next blockchain app with Stratos.",keywords:["docs","stratos","exoswap"],image:"https://raw.githubusercontent.com/stratosnet/token-lists/master/logo.svg"},l=void 0,i={unversionedId:"bridge/contracts/bridge-router",id:"bridge/contracts/bridge-router",title:"Bridge Router",description:"Build your next blockchain app with Stratos.",source:"@site/docs/bridge/contracts/bridge-router.md",sourceDirName:"bridge/contracts",slug:"/bridge/contracts/bridge-router",permalink:"/docs/bridge/contracts/bridge-router",draft:!1,editUrl:"https://github.com/exoswapio/docs/tree/master/docs/bridge/contracts/bridge-router.md",tags:[],version:"current",frontMatter:{id:"bridge-router",title:"Bridge Router",description:"Build your next blockchain app with Stratos.",keywords:["docs","stratos","exoswap"],image:"https://raw.githubusercontent.com/stratosnet/token-lists/master/logo.svg"},sidebar:"bridge",previous:{title:"Bridge Cosigner Manager",permalink:"/docs/bridge/contracts/bridge-cosigner-manager"},next:{title:"Network",permalink:"/docs/develop/network-details/network"}},u={},s=[{value:"enter",id:"enter",level:3},{value:"enterETH",id:"entereth",level:3},{value:"exit",id:"exit",level:3}],c={toc:s},d="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The Bridge Router is a core functionality that manages token issuing (including transfer or mint/burn), double-spend protection, and re-entrancy guarding. Its functionality API is simple and mature. To initiate a bridge process, the smart contract function 'enter' is used on the local chain, which means \"Make an entry to a bridge process for the next exit process\". After 'enter', the process is always expected to be finalized with the 'exit' smart contract process, meaning \"All checks in 'enter' have passed, and the process is finalized\" on the external chain."),(0,a.kt)("p",null,"Shortly:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"enter -> exit")),(0,a.kt)("p",null,"Depends on token type - donored or syndicated the following represented in chart during this processes:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null}),(0,a.kt)("th",{parentName:"tr",align:null},"Donored"),(0,a.kt)("th",{parentName:"tr",align:null},"Syndicated"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Token prefix"),(0,a.kt)("td",{parentName:"tr",align:null},"STOS",(0,a.kt)("br",null)," USDT",(0,a.kt)("br",null)," DAI",(0,a.kt)("br",null)," BNB",(0,a.kt)("br",null)," ETH",(0,a.kt)("br",null)," MATIC"),(0,a.kt)("td",{parentName:"tr",align:null},"STOS",(0,a.kt)("br",null)," USDT",(0,a.kt)("br",null)," DAI",(0,a.kt)("br",null)," BNB",(0,a.kt)("br",null)," ETH",(0,a.kt)("br",null)," MATIC")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Enter"),(0,a.kt)("td",{parentName:"tr",align:null},"Lock"),(0,a.kt)("td",{parentName:"tr",align:null},"Burn")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Exit"),(0,a.kt)("td",{parentName:"tr",align:null},"Unlock"),(0,a.kt)("td",{parentName:"tr",align:null},"Mint")))),(0,a.kt)("p",null,"For different token types like ERC-20/Native, the 'enter' and 'enterETH' functions are used respectively. We use 'ETH' in terms of understanding that the native currency with payable will be used, making the API consistent across all EVM chains. So, to move STOS tokens from Stratos or ETH tokens from Ethereum, the 'enterETH' function will be used."),(0,a.kt)("h3",{id:"enter"},"enter"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"function enter(\n    address token,\n    uint256 amount,\n    uint256 amountMin,\n    uint256 deadline,\n    uint256 targetChainId\n) external;\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Should not allow zero token to be used in this function (zero means native token);"),(0,a.kt)("li",{parentName:"ul"},"Target chain could not be equal to local chain, token manager is responsible for this;"),(0,a.kt)("li",{parentName:"ul"},"Should not accept zero amount;"),(0,a.kt)("li",{parentName:"ul"},"Should increase nonce after each successful execution;"),(0,a.kt)("li",{parentName:"ul"},"Could not burn if amount does not exists on address;"),(0,a.kt)("li",{parentName:"ul"},"Could not withdraw from address if not enough balance;"),(0,a.kt)("li",{parentName:"ul"},"Token address should be address;"),(0,a.kt)("li",{parentName:"ul"},"Deadline should be greater than block execution time;"),(0,a.kt)("li",{parentName:"ul"},"Amount min should be less than amount (for relayer price deviation calculation + fee);"),(0,a.kt)("li",{parentName:"ul"},"Amount min could be equal to amount if tx will be without relayer;")),(0,a.kt)("h3",{id:"entereth"},"enterETH"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"function enterETH(\n    uint256 amountMin,\n    uint256 deadline,\n    uint256 targetChainId\n) external payable;\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Should allow only native currency;"),(0,a.kt)("li",{parentName:"ul"},"Target chain could not be equal to local chain, token manager is responsible for this;"),(0,a.kt)("li",{parentName:"ul"},"Should not accept zero amount;"),(0,a.kt)("li",{parentName:"ul"},"Native token should be enable in token manager;"),(0,a.kt)("li",{parentName:"ul"},"Not responsible for burn or mint;"),(0,a.kt)("li",{parentName:"ul"},"Should increase nonce after each successful execution;"),(0,a.kt)("li",{parentName:"ul"},"Deadline should be greater than block execution time;"),(0,a.kt)("li",{parentName:"ul"},"Amount min should be less than amount (for relayer price deviation calculation + fee);"),(0,a.kt)("li",{parentName:"ul"},"Amount min could be equal to amount if tx will be without relayer;")),(0,a.kt)("h3",{id:"exit"},"exit"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct ProcessorParams {\n    uint256 gasLimit;\n    bool useRelay;\n}\n\nfunction exit(\n    bytes calldata data,\n    bytes[] calldata signatures,\n    ProcessorParams calldata params\n) external;\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Should mint/transfer tokens on sender address;"),(0,a.kt)("li",{parentName:"ul"},"Sender address should be the same as it was during enter process;"),(0,a.kt)("li",{parentName:"ul"},"Should be protected from re-entrancy;"),(0,a.kt)("li",{parentName:"ul"},"Should be protected from double spend;"),(0,a.kt)("li",{parentName:"ul"},"Should have enough exoswap signatures to complete this operation;"),(0,a.kt)("li",{parentName:"ul"},"Process params adding control for gas execution limitation and mostly for relayer purposes;")))}p.isMDXComponent=!0}}]);